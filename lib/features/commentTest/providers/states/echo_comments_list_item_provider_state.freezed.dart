// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'echo_comments_list_item_provider_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$EchoCommentsListItemProviderState {
  /// Whether the replies of this comment are visible or not.
  bool get isRepliesVisible => throw _privateConstructorUsedError;

  /// The state of fetching the comments for the feed.
  FetchEchoCommentsReplyState get fetchCommentsReplyState =>
      throw _privateConstructorUsedError;

  /// The state of creating a comment.
  CreateEchoCommentState get createEchoCommentState =>
      throw _privateConstructorUsedError;

  /// The state of reacting to the comment.
  ReactToEchoCommentState get reactToEchoCommentState =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $EchoCommentsListItemProviderStateCopyWith<EchoCommentsListItemProviderState>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EchoCommentsListItemProviderStateCopyWith<$Res> {
  factory $EchoCommentsListItemProviderStateCopyWith(
          EchoCommentsListItemProviderState value,
          $Res Function(EchoCommentsListItemProviderState) then) =
      _$EchoCommentsListItemProviderStateCopyWithImpl<$Res,
          EchoCommentsListItemProviderState>;
  @useResult
  $Res call(
      {bool isRepliesVisible,
      FetchEchoCommentsReplyState fetchCommentsReplyState,
      CreateEchoCommentState createEchoCommentState,
      ReactToEchoCommentState reactToEchoCommentState});

  $FetchEchoCommentsReplyStateCopyWith<$Res> get fetchCommentsReplyState;
  $CreateEchoCommentStateCopyWith<$Res> get createEchoCommentState;
  $ReactToEchoCommentStateCopyWith<$Res> get reactToEchoCommentState;
}

/// @nodoc
class _$EchoCommentsListItemProviderStateCopyWithImpl<$Res,
        $Val extends EchoCommentsListItemProviderState>
    implements $EchoCommentsListItemProviderStateCopyWith<$Res> {
  _$EchoCommentsListItemProviderStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isRepliesVisible = null,
    Object? fetchCommentsReplyState = null,
    Object? createEchoCommentState = null,
    Object? reactToEchoCommentState = null,
  }) {
    return _then(_value.copyWith(
      isRepliesVisible: null == isRepliesVisible
          ? _value.isRepliesVisible
          : isRepliesVisible // ignore: cast_nullable_to_non_nullable
              as bool,
      fetchCommentsReplyState: null == fetchCommentsReplyState
          ? _value.fetchCommentsReplyState
          : fetchCommentsReplyState // ignore: cast_nullable_to_non_nullable
              as FetchEchoCommentsReplyState,
      createEchoCommentState: null == createEchoCommentState
          ? _value.createEchoCommentState
          : createEchoCommentState // ignore: cast_nullable_to_non_nullable
              as CreateEchoCommentState,
      reactToEchoCommentState: null == reactToEchoCommentState
          ? _value.reactToEchoCommentState
          : reactToEchoCommentState // ignore: cast_nullable_to_non_nullable
              as ReactToEchoCommentState,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $FetchEchoCommentsReplyStateCopyWith<$Res> get fetchCommentsReplyState {
    return $FetchEchoCommentsReplyStateCopyWith<$Res>(
        _value.fetchCommentsReplyState, (value) {
      return _then(_value.copyWith(fetchCommentsReplyState: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CreateEchoCommentStateCopyWith<$Res> get createEchoCommentState {
    return $CreateEchoCommentStateCopyWith<$Res>(_value.createEchoCommentState,
        (value) {
      return _then(_value.copyWith(createEchoCommentState: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReactToEchoCommentStateCopyWith<$Res> get reactToEchoCommentState {
    return $ReactToEchoCommentStateCopyWith<$Res>(
        _value.reactToEchoCommentState, (value) {
      return _then(_value.copyWith(reactToEchoCommentState: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$EchoCommentsListItemProviderStateImplCopyWith<$Res>
    implements $EchoCommentsListItemProviderStateCopyWith<$Res> {
  factory _$$EchoCommentsListItemProviderStateImplCopyWith(
          _$EchoCommentsListItemProviderStateImpl value,
          $Res Function(_$EchoCommentsListItemProviderStateImpl) then) =
      __$$EchoCommentsListItemProviderStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {bool isRepliesVisible,
      FetchEchoCommentsReplyState fetchCommentsReplyState,
      CreateEchoCommentState createEchoCommentState,
      ReactToEchoCommentState reactToEchoCommentState});

  @override
  $FetchEchoCommentsReplyStateCopyWith<$Res> get fetchCommentsReplyState;
  @override
  $CreateEchoCommentStateCopyWith<$Res> get createEchoCommentState;
  @override
  $ReactToEchoCommentStateCopyWith<$Res> get reactToEchoCommentState;
}

/// @nodoc
class __$$EchoCommentsListItemProviderStateImplCopyWithImpl<$Res>
    extends _$EchoCommentsListItemProviderStateCopyWithImpl<$Res,
        _$EchoCommentsListItemProviderStateImpl>
    implements _$$EchoCommentsListItemProviderStateImplCopyWith<$Res> {
  __$$EchoCommentsListItemProviderStateImplCopyWithImpl(
      _$EchoCommentsListItemProviderStateImpl _value,
      $Res Function(_$EchoCommentsListItemProviderStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isRepliesVisible = null,
    Object? fetchCommentsReplyState = null,
    Object? createEchoCommentState = null,
    Object? reactToEchoCommentState = null,
  }) {
    return _then(_$EchoCommentsListItemProviderStateImpl(
      isRepliesVisible: null == isRepliesVisible
          ? _value.isRepliesVisible
          : isRepliesVisible // ignore: cast_nullable_to_non_nullable
              as bool,
      fetchCommentsReplyState: null == fetchCommentsReplyState
          ? _value.fetchCommentsReplyState
          : fetchCommentsReplyState // ignore: cast_nullable_to_non_nullable
              as FetchEchoCommentsReplyState,
      createEchoCommentState: null == createEchoCommentState
          ? _value.createEchoCommentState
          : createEchoCommentState // ignore: cast_nullable_to_non_nullable
              as CreateEchoCommentState,
      reactToEchoCommentState: null == reactToEchoCommentState
          ? _value.reactToEchoCommentState
          : reactToEchoCommentState // ignore: cast_nullable_to_non_nullable
              as ReactToEchoCommentState,
    ));
  }
}

/// @nodoc

class _$EchoCommentsListItemProviderStateImpl
    implements _EchoCommentsListItemProviderState {
  const _$EchoCommentsListItemProviderStateImpl(
      {this.isRepliesVisible = false,
      this.fetchCommentsReplyState =
          const FetchEchoCommentsReplyState.initial(),
      this.createEchoCommentState = const CreateEchoCommentState.initial(),
      this.reactToEchoCommentState = const ReactToEchoCommentState.initial()});

  /// Whether the replies of this comment are visible or not.
  @override
  @JsonKey()
  final bool isRepliesVisible;

  /// The state of fetching the comments for the feed.
  @override
  @JsonKey()
  final FetchEchoCommentsReplyState fetchCommentsReplyState;

  /// The state of creating a comment.
  @override
  @JsonKey()
  final CreateEchoCommentState createEchoCommentState;

  /// The state of reacting to the comment.
  @override
  @JsonKey()
  final ReactToEchoCommentState reactToEchoCommentState;

  @override
  String toString() {
    return 'EchoCommentsListItemProviderState(isRepliesVisible: $isRepliesVisible, fetchCommentsReplyState: $fetchCommentsReplyState, createEchoCommentState: $createEchoCommentState, reactToEchoCommentState: $reactToEchoCommentState)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EchoCommentsListItemProviderStateImpl &&
            (identical(other.isRepliesVisible, isRepliesVisible) ||
                other.isRepliesVisible == isRepliesVisible) &&
            (identical(
                    other.fetchCommentsReplyState, fetchCommentsReplyState) ||
                other.fetchCommentsReplyState == fetchCommentsReplyState) &&
            (identical(other.createEchoCommentState, createEchoCommentState) ||
                other.createEchoCommentState == createEchoCommentState) &&
            (identical(
                    other.reactToEchoCommentState, reactToEchoCommentState) ||
                other.reactToEchoCommentState == reactToEchoCommentState));
  }

  @override
  int get hashCode => Object.hash(runtimeType, isRepliesVisible,
      fetchCommentsReplyState, createEchoCommentState, reactToEchoCommentState);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EchoCommentsListItemProviderStateImplCopyWith<
          _$EchoCommentsListItemProviderStateImpl>
      get copyWith => __$$EchoCommentsListItemProviderStateImplCopyWithImpl<
          _$EchoCommentsListItemProviderStateImpl>(this, _$identity);
}

abstract class _EchoCommentsListItemProviderState
    implements EchoCommentsListItemProviderState {
  const factory _EchoCommentsListItemProviderState(
          {final bool isRepliesVisible,
          final FetchEchoCommentsReplyState fetchCommentsReplyState,
          final CreateEchoCommentState createEchoCommentState,
          final ReactToEchoCommentState reactToEchoCommentState}) =
      _$EchoCommentsListItemProviderStateImpl;

  @override

  /// Whether the replies of this comment are visible or not.
  bool get isRepliesVisible;
  @override

  /// The state of fetching the comments for the feed.
  FetchEchoCommentsReplyState get fetchCommentsReplyState;
  @override

  /// The state of creating a comment.
  CreateEchoCommentState get createEchoCommentState;
  @override

  /// The state of reacting to the comment.
  ReactToEchoCommentState get reactToEchoCommentState;
  @override
  @JsonKey(ignore: true)
  _$$EchoCommentsListItemProviderStateImplCopyWith<
          _$EchoCommentsListItemProviderStateImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$FetchEchoCommentsReplyState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<PeamanComment> result) success,
    required TResult Function(PeamanError error) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<PeamanComment> result)? success,
    TResult? Function(PeamanError error)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<PeamanComment> result)? success,
    TResult Function(PeamanError error)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FetchEchoCommentsReplyStateInitial value)
        initial,
    required TResult Function(_FetchEchoCommentsReplyStateLoading value)
        loading,
    required TResult Function(_FetchEchoCommentsReplyStateSuccess value)
        success,
    required TResult Function(_FetchEchoCommentsReplyStateError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FetchEchoCommentsReplyStateInitial value)? initial,
    TResult? Function(_FetchEchoCommentsReplyStateLoading value)? loading,
    TResult? Function(_FetchEchoCommentsReplyStateSuccess value)? success,
    TResult? Function(_FetchEchoCommentsReplyStateError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FetchEchoCommentsReplyStateInitial value)? initial,
    TResult Function(_FetchEchoCommentsReplyStateLoading value)? loading,
    TResult Function(_FetchEchoCommentsReplyStateSuccess value)? success,
    TResult Function(_FetchEchoCommentsReplyStateError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FetchEchoCommentsReplyStateCopyWith<$Res> {
  factory $FetchEchoCommentsReplyStateCopyWith(
          FetchEchoCommentsReplyState value,
          $Res Function(FetchEchoCommentsReplyState) then) =
      _$FetchEchoCommentsReplyStateCopyWithImpl<$Res,
          FetchEchoCommentsReplyState>;
}

/// @nodoc
class _$FetchEchoCommentsReplyStateCopyWithImpl<$Res,
        $Val extends FetchEchoCommentsReplyState>
    implements $FetchEchoCommentsReplyStateCopyWith<$Res> {
  _$FetchEchoCommentsReplyStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$FetchEchoCommentsReplyStateInitialImplCopyWith<$Res> {
  factory _$$FetchEchoCommentsReplyStateInitialImplCopyWith(
          _$FetchEchoCommentsReplyStateInitialImpl value,
          $Res Function(_$FetchEchoCommentsReplyStateInitialImpl) then) =
      __$$FetchEchoCommentsReplyStateInitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$FetchEchoCommentsReplyStateInitialImplCopyWithImpl<$Res>
    extends _$FetchEchoCommentsReplyStateCopyWithImpl<$Res,
        _$FetchEchoCommentsReplyStateInitialImpl>
    implements _$$FetchEchoCommentsReplyStateInitialImplCopyWith<$Res> {
  __$$FetchEchoCommentsReplyStateInitialImplCopyWithImpl(
      _$FetchEchoCommentsReplyStateInitialImpl _value,
      $Res Function(_$FetchEchoCommentsReplyStateInitialImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$FetchEchoCommentsReplyStateInitialImpl
    implements _FetchEchoCommentsReplyStateInitial {
  const _$FetchEchoCommentsReplyStateInitialImpl();

  @override
  String toString() {
    return 'FetchEchoCommentsReplyState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FetchEchoCommentsReplyStateInitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<PeamanComment> result) success,
    required TResult Function(PeamanError error) error,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<PeamanComment> result)? success,
    TResult? Function(PeamanError error)? error,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<PeamanComment> result)? success,
    TResult Function(PeamanError error)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FetchEchoCommentsReplyStateInitial value)
        initial,
    required TResult Function(_FetchEchoCommentsReplyStateLoading value)
        loading,
    required TResult Function(_FetchEchoCommentsReplyStateSuccess value)
        success,
    required TResult Function(_FetchEchoCommentsReplyStateError value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FetchEchoCommentsReplyStateInitial value)? initial,
    TResult? Function(_FetchEchoCommentsReplyStateLoading value)? loading,
    TResult? Function(_FetchEchoCommentsReplyStateSuccess value)? success,
    TResult? Function(_FetchEchoCommentsReplyStateError value)? error,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FetchEchoCommentsReplyStateInitial value)? initial,
    TResult Function(_FetchEchoCommentsReplyStateLoading value)? loading,
    TResult Function(_FetchEchoCommentsReplyStateSuccess value)? success,
    TResult Function(_FetchEchoCommentsReplyStateError value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _FetchEchoCommentsReplyStateInitial
    implements FetchEchoCommentsReplyState {
  const factory _FetchEchoCommentsReplyStateInitial() =
      _$FetchEchoCommentsReplyStateInitialImpl;
}

/// @nodoc
abstract class _$$FetchEchoCommentsReplyStateLoadingImplCopyWith<$Res> {
  factory _$$FetchEchoCommentsReplyStateLoadingImplCopyWith(
          _$FetchEchoCommentsReplyStateLoadingImpl value,
          $Res Function(_$FetchEchoCommentsReplyStateLoadingImpl) then) =
      __$$FetchEchoCommentsReplyStateLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$FetchEchoCommentsReplyStateLoadingImplCopyWithImpl<$Res>
    extends _$FetchEchoCommentsReplyStateCopyWithImpl<$Res,
        _$FetchEchoCommentsReplyStateLoadingImpl>
    implements _$$FetchEchoCommentsReplyStateLoadingImplCopyWith<$Res> {
  __$$FetchEchoCommentsReplyStateLoadingImplCopyWithImpl(
      _$FetchEchoCommentsReplyStateLoadingImpl _value,
      $Res Function(_$FetchEchoCommentsReplyStateLoadingImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$FetchEchoCommentsReplyStateLoadingImpl
    implements _FetchEchoCommentsReplyStateLoading {
  const _$FetchEchoCommentsReplyStateLoadingImpl();

  @override
  String toString() {
    return 'FetchEchoCommentsReplyState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FetchEchoCommentsReplyStateLoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<PeamanComment> result) success,
    required TResult Function(PeamanError error) error,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<PeamanComment> result)? success,
    TResult? Function(PeamanError error)? error,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<PeamanComment> result)? success,
    TResult Function(PeamanError error)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FetchEchoCommentsReplyStateInitial value)
        initial,
    required TResult Function(_FetchEchoCommentsReplyStateLoading value)
        loading,
    required TResult Function(_FetchEchoCommentsReplyStateSuccess value)
        success,
    required TResult Function(_FetchEchoCommentsReplyStateError value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FetchEchoCommentsReplyStateInitial value)? initial,
    TResult? Function(_FetchEchoCommentsReplyStateLoading value)? loading,
    TResult? Function(_FetchEchoCommentsReplyStateSuccess value)? success,
    TResult? Function(_FetchEchoCommentsReplyStateError value)? error,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FetchEchoCommentsReplyStateInitial value)? initial,
    TResult Function(_FetchEchoCommentsReplyStateLoading value)? loading,
    TResult Function(_FetchEchoCommentsReplyStateSuccess value)? success,
    TResult Function(_FetchEchoCommentsReplyStateError value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _FetchEchoCommentsReplyStateLoading
    implements FetchEchoCommentsReplyState {
  const factory _FetchEchoCommentsReplyStateLoading() =
      _$FetchEchoCommentsReplyStateLoadingImpl;
}

/// @nodoc
abstract class _$$FetchEchoCommentsReplyStateSuccessImplCopyWith<$Res> {
  factory _$$FetchEchoCommentsReplyStateSuccessImplCopyWith(
          _$FetchEchoCommentsReplyStateSuccessImpl value,
          $Res Function(_$FetchEchoCommentsReplyStateSuccessImpl) then) =
      __$$FetchEchoCommentsReplyStateSuccessImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<PeamanComment> result});
}

/// @nodoc
class __$$FetchEchoCommentsReplyStateSuccessImplCopyWithImpl<$Res>
    extends _$FetchEchoCommentsReplyStateCopyWithImpl<$Res,
        _$FetchEchoCommentsReplyStateSuccessImpl>
    implements _$$FetchEchoCommentsReplyStateSuccessImplCopyWith<$Res> {
  __$$FetchEchoCommentsReplyStateSuccessImplCopyWithImpl(
      _$FetchEchoCommentsReplyStateSuccessImpl _value,
      $Res Function(_$FetchEchoCommentsReplyStateSuccessImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? result = null,
  }) {
    return _then(_$FetchEchoCommentsReplyStateSuccessImpl(
      null == result
          ? _value._result
          : result // ignore: cast_nullable_to_non_nullable
              as List<PeamanComment>,
    ));
  }
}

/// @nodoc

class _$FetchEchoCommentsReplyStateSuccessImpl
    implements _FetchEchoCommentsReplyStateSuccess {
  const _$FetchEchoCommentsReplyStateSuccessImpl(
      final List<PeamanComment> result)
      : _result = result;

  final List<PeamanComment> _result;
  @override
  List<PeamanComment> get result {
    if (_result is EqualUnmodifiableListView) return _result;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_result);
  }

  @override
  String toString() {
    return 'FetchEchoCommentsReplyState.success(result: $result)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FetchEchoCommentsReplyStateSuccessImpl &&
            const DeepCollectionEquality().equals(other._result, _result));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_result));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FetchEchoCommentsReplyStateSuccessImplCopyWith<
          _$FetchEchoCommentsReplyStateSuccessImpl>
      get copyWith => __$$FetchEchoCommentsReplyStateSuccessImplCopyWithImpl<
          _$FetchEchoCommentsReplyStateSuccessImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<PeamanComment> result) success,
    required TResult Function(PeamanError error) error,
  }) {
    return success(result);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<PeamanComment> result)? success,
    TResult? Function(PeamanError error)? error,
  }) {
    return success?.call(result);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<PeamanComment> result)? success,
    TResult Function(PeamanError error)? error,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(result);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FetchEchoCommentsReplyStateInitial value)
        initial,
    required TResult Function(_FetchEchoCommentsReplyStateLoading value)
        loading,
    required TResult Function(_FetchEchoCommentsReplyStateSuccess value)
        success,
    required TResult Function(_FetchEchoCommentsReplyStateError value) error,
  }) {
    return success(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FetchEchoCommentsReplyStateInitial value)? initial,
    TResult? Function(_FetchEchoCommentsReplyStateLoading value)? loading,
    TResult? Function(_FetchEchoCommentsReplyStateSuccess value)? success,
    TResult? Function(_FetchEchoCommentsReplyStateError value)? error,
  }) {
    return success?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FetchEchoCommentsReplyStateInitial value)? initial,
    TResult Function(_FetchEchoCommentsReplyStateLoading value)? loading,
    TResult Function(_FetchEchoCommentsReplyStateSuccess value)? success,
    TResult Function(_FetchEchoCommentsReplyStateError value)? error,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(this);
    }
    return orElse();
  }
}

abstract class _FetchEchoCommentsReplyStateSuccess
    implements FetchEchoCommentsReplyState {
  const factory _FetchEchoCommentsReplyStateSuccess(
          final List<PeamanComment> result) =
      _$FetchEchoCommentsReplyStateSuccessImpl;

  List<PeamanComment> get result;
  @JsonKey(ignore: true)
  _$$FetchEchoCommentsReplyStateSuccessImplCopyWith<
          _$FetchEchoCommentsReplyStateSuccessImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FetchEchoCommentsReplyStateErrorImplCopyWith<$Res> {
  factory _$$FetchEchoCommentsReplyStateErrorImplCopyWith(
          _$FetchEchoCommentsReplyStateErrorImpl value,
          $Res Function(_$FetchEchoCommentsReplyStateErrorImpl) then) =
      __$$FetchEchoCommentsReplyStateErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({PeamanError error});

  $PeamanErrorCopyWith<$Res> get error;
}

/// @nodoc
class __$$FetchEchoCommentsReplyStateErrorImplCopyWithImpl<$Res>
    extends _$FetchEchoCommentsReplyStateCopyWithImpl<$Res,
        _$FetchEchoCommentsReplyStateErrorImpl>
    implements _$$FetchEchoCommentsReplyStateErrorImplCopyWith<$Res> {
  __$$FetchEchoCommentsReplyStateErrorImplCopyWithImpl(
      _$FetchEchoCommentsReplyStateErrorImpl _value,
      $Res Function(_$FetchEchoCommentsReplyStateErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = null,
  }) {
    return _then(_$FetchEchoCommentsReplyStateErrorImpl(
      null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as PeamanError,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $PeamanErrorCopyWith<$Res> get error {
    return $PeamanErrorCopyWith<$Res>(_value.error, (value) {
      return _then(_value.copyWith(error: value));
    });
  }
}

/// @nodoc

class _$FetchEchoCommentsReplyStateErrorImpl
    implements _FetchEchoCommentsReplyStateError {
  const _$FetchEchoCommentsReplyStateErrorImpl(this.error);

  @override
  final PeamanError error;

  @override
  String toString() {
    return 'FetchEchoCommentsReplyState.error(error: $error)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FetchEchoCommentsReplyStateErrorImpl &&
            (identical(other.error, error) || other.error == error));
  }

  @override
  int get hashCode => Object.hash(runtimeType, error);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FetchEchoCommentsReplyStateErrorImplCopyWith<
          _$FetchEchoCommentsReplyStateErrorImpl>
      get copyWith => __$$FetchEchoCommentsReplyStateErrorImplCopyWithImpl<
          _$FetchEchoCommentsReplyStateErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<PeamanComment> result) success,
    required TResult Function(PeamanError error) error,
  }) {
    return error(this.error);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<PeamanComment> result)? success,
    TResult? Function(PeamanError error)? error,
  }) {
    return error?.call(this.error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<PeamanComment> result)? success,
    TResult Function(PeamanError error)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this.error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FetchEchoCommentsReplyStateInitial value)
        initial,
    required TResult Function(_FetchEchoCommentsReplyStateLoading value)
        loading,
    required TResult Function(_FetchEchoCommentsReplyStateSuccess value)
        success,
    required TResult Function(_FetchEchoCommentsReplyStateError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FetchEchoCommentsReplyStateInitial value)? initial,
    TResult? Function(_FetchEchoCommentsReplyStateLoading value)? loading,
    TResult? Function(_FetchEchoCommentsReplyStateSuccess value)? success,
    TResult? Function(_FetchEchoCommentsReplyStateError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FetchEchoCommentsReplyStateInitial value)? initial,
    TResult Function(_FetchEchoCommentsReplyStateLoading value)? loading,
    TResult Function(_FetchEchoCommentsReplyStateSuccess value)? success,
    TResult Function(_FetchEchoCommentsReplyStateError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class _FetchEchoCommentsReplyStateError
    implements FetchEchoCommentsReplyState {
  const factory _FetchEchoCommentsReplyStateError(final PeamanError error) =
      _$FetchEchoCommentsReplyStateErrorImpl;

  PeamanError get error;
  @JsonKey(ignore: true)
  _$$FetchEchoCommentsReplyStateErrorImplCopyWith<
          _$FetchEchoCommentsReplyStateErrorImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$CreateEchoCommentState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(PeamanComment result) success,
    required TResult Function(PeamanError error) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(PeamanComment result)? success,
    TResult? Function(PeamanError error)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(PeamanComment result)? success,
    TResult Function(PeamanError error)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CreateEchoCommentStateInitial value) initial,
    required TResult Function(_CreateEchoCommentStateLoading value) loading,
    required TResult Function(_CreateEchoCommentStateSuccess value) success,
    required TResult Function(_CreateEchoCommentStateError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CreateEchoCommentStateInitial value)? initial,
    TResult? Function(_CreateEchoCommentStateLoading value)? loading,
    TResult? Function(_CreateEchoCommentStateSuccess value)? success,
    TResult? Function(_CreateEchoCommentStateError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CreateEchoCommentStateInitial value)? initial,
    TResult Function(_CreateEchoCommentStateLoading value)? loading,
    TResult Function(_CreateEchoCommentStateSuccess value)? success,
    TResult Function(_CreateEchoCommentStateError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateEchoCommentStateCopyWith<$Res> {
  factory $CreateEchoCommentStateCopyWith(CreateEchoCommentState value,
          $Res Function(CreateEchoCommentState) then) =
      _$CreateEchoCommentStateCopyWithImpl<$Res, CreateEchoCommentState>;
}

/// @nodoc
class _$CreateEchoCommentStateCopyWithImpl<$Res,
        $Val extends CreateEchoCommentState>
    implements $CreateEchoCommentStateCopyWith<$Res> {
  _$CreateEchoCommentStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$CreateEchoCommentStateInitialImplCopyWith<$Res> {
  factory _$$CreateEchoCommentStateInitialImplCopyWith(
          _$CreateEchoCommentStateInitialImpl value,
          $Res Function(_$CreateEchoCommentStateInitialImpl) then) =
      __$$CreateEchoCommentStateInitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CreateEchoCommentStateInitialImplCopyWithImpl<$Res>
    extends _$CreateEchoCommentStateCopyWithImpl<$Res,
        _$CreateEchoCommentStateInitialImpl>
    implements _$$CreateEchoCommentStateInitialImplCopyWith<$Res> {
  __$$CreateEchoCommentStateInitialImplCopyWithImpl(
      _$CreateEchoCommentStateInitialImpl _value,
      $Res Function(_$CreateEchoCommentStateInitialImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$CreateEchoCommentStateInitialImpl
    implements _CreateEchoCommentStateInitial {
  const _$CreateEchoCommentStateInitialImpl();

  @override
  String toString() {
    return 'CreateEchoCommentState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateEchoCommentStateInitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(PeamanComment result) success,
    required TResult Function(PeamanError error) error,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(PeamanComment result)? success,
    TResult? Function(PeamanError error)? error,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(PeamanComment result)? success,
    TResult Function(PeamanError error)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CreateEchoCommentStateInitial value) initial,
    required TResult Function(_CreateEchoCommentStateLoading value) loading,
    required TResult Function(_CreateEchoCommentStateSuccess value) success,
    required TResult Function(_CreateEchoCommentStateError value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CreateEchoCommentStateInitial value)? initial,
    TResult? Function(_CreateEchoCommentStateLoading value)? loading,
    TResult? Function(_CreateEchoCommentStateSuccess value)? success,
    TResult? Function(_CreateEchoCommentStateError value)? error,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CreateEchoCommentStateInitial value)? initial,
    TResult Function(_CreateEchoCommentStateLoading value)? loading,
    TResult Function(_CreateEchoCommentStateSuccess value)? success,
    TResult Function(_CreateEchoCommentStateError value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _CreateEchoCommentStateInitial
    implements CreateEchoCommentState {
  const factory _CreateEchoCommentStateInitial() =
      _$CreateEchoCommentStateInitialImpl;
}

/// @nodoc
abstract class _$$CreateEchoCommentStateLoadingImplCopyWith<$Res> {
  factory _$$CreateEchoCommentStateLoadingImplCopyWith(
          _$CreateEchoCommentStateLoadingImpl value,
          $Res Function(_$CreateEchoCommentStateLoadingImpl) then) =
      __$$CreateEchoCommentStateLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CreateEchoCommentStateLoadingImplCopyWithImpl<$Res>
    extends _$CreateEchoCommentStateCopyWithImpl<$Res,
        _$CreateEchoCommentStateLoadingImpl>
    implements _$$CreateEchoCommentStateLoadingImplCopyWith<$Res> {
  __$$CreateEchoCommentStateLoadingImplCopyWithImpl(
      _$CreateEchoCommentStateLoadingImpl _value,
      $Res Function(_$CreateEchoCommentStateLoadingImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$CreateEchoCommentStateLoadingImpl
    implements _CreateEchoCommentStateLoading {
  const _$CreateEchoCommentStateLoadingImpl();

  @override
  String toString() {
    return 'CreateEchoCommentState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateEchoCommentStateLoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(PeamanComment result) success,
    required TResult Function(PeamanError error) error,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(PeamanComment result)? success,
    TResult? Function(PeamanError error)? error,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(PeamanComment result)? success,
    TResult Function(PeamanError error)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CreateEchoCommentStateInitial value) initial,
    required TResult Function(_CreateEchoCommentStateLoading value) loading,
    required TResult Function(_CreateEchoCommentStateSuccess value) success,
    required TResult Function(_CreateEchoCommentStateError value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CreateEchoCommentStateInitial value)? initial,
    TResult? Function(_CreateEchoCommentStateLoading value)? loading,
    TResult? Function(_CreateEchoCommentStateSuccess value)? success,
    TResult? Function(_CreateEchoCommentStateError value)? error,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CreateEchoCommentStateInitial value)? initial,
    TResult Function(_CreateEchoCommentStateLoading value)? loading,
    TResult Function(_CreateEchoCommentStateSuccess value)? success,
    TResult Function(_CreateEchoCommentStateError value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _CreateEchoCommentStateLoading
    implements CreateEchoCommentState {
  const factory _CreateEchoCommentStateLoading() =
      _$CreateEchoCommentStateLoadingImpl;
}

/// @nodoc
abstract class _$$CreateEchoCommentStateSuccessImplCopyWith<$Res> {
  factory _$$CreateEchoCommentStateSuccessImplCopyWith(
          _$CreateEchoCommentStateSuccessImpl value,
          $Res Function(_$CreateEchoCommentStateSuccessImpl) then) =
      __$$CreateEchoCommentStateSuccessImplCopyWithImpl<$Res>;
  @useResult
  $Res call({PeamanComment result});

  $PeamanCommentCopyWith<$Res> get result;
}

/// @nodoc
class __$$CreateEchoCommentStateSuccessImplCopyWithImpl<$Res>
    extends _$CreateEchoCommentStateCopyWithImpl<$Res,
        _$CreateEchoCommentStateSuccessImpl>
    implements _$$CreateEchoCommentStateSuccessImplCopyWith<$Res> {
  __$$CreateEchoCommentStateSuccessImplCopyWithImpl(
      _$CreateEchoCommentStateSuccessImpl _value,
      $Res Function(_$CreateEchoCommentStateSuccessImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? result = null,
  }) {
    return _then(_$CreateEchoCommentStateSuccessImpl(
      null == result
          ? _value.result
          : result // ignore: cast_nullable_to_non_nullable
              as PeamanComment,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $PeamanCommentCopyWith<$Res> get result {
    return $PeamanCommentCopyWith<$Res>(_value.result, (value) {
      return _then(_value.copyWith(result: value));
    });
  }
}

/// @nodoc

class _$CreateEchoCommentStateSuccessImpl
    implements _CreateEchoCommentStateSuccess {
  const _$CreateEchoCommentStateSuccessImpl(this.result);

  @override
  final PeamanComment result;

  @override
  String toString() {
    return 'CreateEchoCommentState.success(result: $result)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateEchoCommentStateSuccessImpl &&
            (identical(other.result, result) || other.result == result));
  }

  @override
  int get hashCode => Object.hash(runtimeType, result);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateEchoCommentStateSuccessImplCopyWith<
          _$CreateEchoCommentStateSuccessImpl>
      get copyWith => __$$CreateEchoCommentStateSuccessImplCopyWithImpl<
          _$CreateEchoCommentStateSuccessImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(PeamanComment result) success,
    required TResult Function(PeamanError error) error,
  }) {
    return success(result);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(PeamanComment result)? success,
    TResult? Function(PeamanError error)? error,
  }) {
    return success?.call(result);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(PeamanComment result)? success,
    TResult Function(PeamanError error)? error,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(result);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CreateEchoCommentStateInitial value) initial,
    required TResult Function(_CreateEchoCommentStateLoading value) loading,
    required TResult Function(_CreateEchoCommentStateSuccess value) success,
    required TResult Function(_CreateEchoCommentStateError value) error,
  }) {
    return success(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CreateEchoCommentStateInitial value)? initial,
    TResult? Function(_CreateEchoCommentStateLoading value)? loading,
    TResult? Function(_CreateEchoCommentStateSuccess value)? success,
    TResult? Function(_CreateEchoCommentStateError value)? error,
  }) {
    return success?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CreateEchoCommentStateInitial value)? initial,
    TResult Function(_CreateEchoCommentStateLoading value)? loading,
    TResult Function(_CreateEchoCommentStateSuccess value)? success,
    TResult Function(_CreateEchoCommentStateError value)? error,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(this);
    }
    return orElse();
  }
}

abstract class _CreateEchoCommentStateSuccess
    implements CreateEchoCommentState {
  const factory _CreateEchoCommentStateSuccess(final PeamanComment result) =
      _$CreateEchoCommentStateSuccessImpl;

  PeamanComment get result;
  @JsonKey(ignore: true)
  _$$CreateEchoCommentStateSuccessImplCopyWith<
          _$CreateEchoCommentStateSuccessImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CreateEchoCommentStateErrorImplCopyWith<$Res> {
  factory _$$CreateEchoCommentStateErrorImplCopyWith(
          _$CreateEchoCommentStateErrorImpl value,
          $Res Function(_$CreateEchoCommentStateErrorImpl) then) =
      __$$CreateEchoCommentStateErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({PeamanError error});

  $PeamanErrorCopyWith<$Res> get error;
}

/// @nodoc
class __$$CreateEchoCommentStateErrorImplCopyWithImpl<$Res>
    extends _$CreateEchoCommentStateCopyWithImpl<$Res,
        _$CreateEchoCommentStateErrorImpl>
    implements _$$CreateEchoCommentStateErrorImplCopyWith<$Res> {
  __$$CreateEchoCommentStateErrorImplCopyWithImpl(
      _$CreateEchoCommentStateErrorImpl _value,
      $Res Function(_$CreateEchoCommentStateErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = null,
  }) {
    return _then(_$CreateEchoCommentStateErrorImpl(
      null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as PeamanError,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $PeamanErrorCopyWith<$Res> get error {
    return $PeamanErrorCopyWith<$Res>(_value.error, (value) {
      return _then(_value.copyWith(error: value));
    });
  }
}

/// @nodoc

class _$CreateEchoCommentStateErrorImpl
    implements _CreateEchoCommentStateError {
  const _$CreateEchoCommentStateErrorImpl(this.error);

  @override
  final PeamanError error;

  @override
  String toString() {
    return 'CreateEchoCommentState.error(error: $error)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateEchoCommentStateErrorImpl &&
            (identical(other.error, error) || other.error == error));
  }

  @override
  int get hashCode => Object.hash(runtimeType, error);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateEchoCommentStateErrorImplCopyWith<_$CreateEchoCommentStateErrorImpl>
      get copyWith => __$$CreateEchoCommentStateErrorImplCopyWithImpl<
          _$CreateEchoCommentStateErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(PeamanComment result) success,
    required TResult Function(PeamanError error) error,
  }) {
    return error(this.error);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(PeamanComment result)? success,
    TResult? Function(PeamanError error)? error,
  }) {
    return error?.call(this.error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(PeamanComment result)? success,
    TResult Function(PeamanError error)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this.error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CreateEchoCommentStateInitial value) initial,
    required TResult Function(_CreateEchoCommentStateLoading value) loading,
    required TResult Function(_CreateEchoCommentStateSuccess value) success,
    required TResult Function(_CreateEchoCommentStateError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CreateEchoCommentStateInitial value)? initial,
    TResult? Function(_CreateEchoCommentStateLoading value)? loading,
    TResult? Function(_CreateEchoCommentStateSuccess value)? success,
    TResult? Function(_CreateEchoCommentStateError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CreateEchoCommentStateInitial value)? initial,
    TResult Function(_CreateEchoCommentStateLoading value)? loading,
    TResult Function(_CreateEchoCommentStateSuccess value)? success,
    TResult Function(_CreateEchoCommentStateError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class _CreateEchoCommentStateError implements CreateEchoCommentState {
  const factory _CreateEchoCommentStateError(final PeamanError error) =
      _$CreateEchoCommentStateErrorImpl;

  PeamanError get error;
  @JsonKey(ignore: true)
  _$$CreateEchoCommentStateErrorImplCopyWith<_$CreateEchoCommentStateErrorImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ReactToEchoCommentState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(PeamanReaction result) success,
    required TResult Function(PeamanError error) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(PeamanReaction result)? success,
    TResult? Function(PeamanError error)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(PeamanReaction result)? success,
    TResult Function(PeamanError error)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ReactToEchoCommentStateInitial value) initial,
    required TResult Function(_ReactToEchoCommentStateLoading value) loading,
    required TResult Function(_ReactToEchoCommentStateSuccess value) success,
    required TResult Function(_ReactToEchoCommentStateError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_ReactToEchoCommentStateInitial value)? initial,
    TResult? Function(_ReactToEchoCommentStateLoading value)? loading,
    TResult? Function(_ReactToEchoCommentStateSuccess value)? success,
    TResult? Function(_ReactToEchoCommentStateError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ReactToEchoCommentStateInitial value)? initial,
    TResult Function(_ReactToEchoCommentStateLoading value)? loading,
    TResult Function(_ReactToEchoCommentStateSuccess value)? success,
    TResult Function(_ReactToEchoCommentStateError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ReactToEchoCommentStateCopyWith<$Res> {
  factory $ReactToEchoCommentStateCopyWith(ReactToEchoCommentState value,
          $Res Function(ReactToEchoCommentState) then) =
      _$ReactToEchoCommentStateCopyWithImpl<$Res, ReactToEchoCommentState>;
}

/// @nodoc
class _$ReactToEchoCommentStateCopyWithImpl<$Res,
        $Val extends ReactToEchoCommentState>
    implements $ReactToEchoCommentStateCopyWith<$Res> {
  _$ReactToEchoCommentStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$ReactToEchoCommentStateInitialImplCopyWith<$Res> {
  factory _$$ReactToEchoCommentStateInitialImplCopyWith(
          _$ReactToEchoCommentStateInitialImpl value,
          $Res Function(_$ReactToEchoCommentStateInitialImpl) then) =
      __$$ReactToEchoCommentStateInitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ReactToEchoCommentStateInitialImplCopyWithImpl<$Res>
    extends _$ReactToEchoCommentStateCopyWithImpl<$Res,
        _$ReactToEchoCommentStateInitialImpl>
    implements _$$ReactToEchoCommentStateInitialImplCopyWith<$Res> {
  __$$ReactToEchoCommentStateInitialImplCopyWithImpl(
      _$ReactToEchoCommentStateInitialImpl _value,
      $Res Function(_$ReactToEchoCommentStateInitialImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ReactToEchoCommentStateInitialImpl
    implements _ReactToEchoCommentStateInitial {
  const _$ReactToEchoCommentStateInitialImpl();

  @override
  String toString() {
    return 'ReactToEchoCommentState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ReactToEchoCommentStateInitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(PeamanReaction result) success,
    required TResult Function(PeamanError error) error,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(PeamanReaction result)? success,
    TResult? Function(PeamanError error)? error,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(PeamanReaction result)? success,
    TResult Function(PeamanError error)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ReactToEchoCommentStateInitial value) initial,
    required TResult Function(_ReactToEchoCommentStateLoading value) loading,
    required TResult Function(_ReactToEchoCommentStateSuccess value) success,
    required TResult Function(_ReactToEchoCommentStateError value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_ReactToEchoCommentStateInitial value)? initial,
    TResult? Function(_ReactToEchoCommentStateLoading value)? loading,
    TResult? Function(_ReactToEchoCommentStateSuccess value)? success,
    TResult? Function(_ReactToEchoCommentStateError value)? error,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ReactToEchoCommentStateInitial value)? initial,
    TResult Function(_ReactToEchoCommentStateLoading value)? loading,
    TResult Function(_ReactToEchoCommentStateSuccess value)? success,
    TResult Function(_ReactToEchoCommentStateError value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _ReactToEchoCommentStateInitial
    implements ReactToEchoCommentState {
  const factory _ReactToEchoCommentStateInitial() =
      _$ReactToEchoCommentStateInitialImpl;
}

/// @nodoc
abstract class _$$ReactToEchoCommentStateLoadingImplCopyWith<$Res> {
  factory _$$ReactToEchoCommentStateLoadingImplCopyWith(
          _$ReactToEchoCommentStateLoadingImpl value,
          $Res Function(_$ReactToEchoCommentStateLoadingImpl) then) =
      __$$ReactToEchoCommentStateLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ReactToEchoCommentStateLoadingImplCopyWithImpl<$Res>
    extends _$ReactToEchoCommentStateCopyWithImpl<$Res,
        _$ReactToEchoCommentStateLoadingImpl>
    implements _$$ReactToEchoCommentStateLoadingImplCopyWith<$Res> {
  __$$ReactToEchoCommentStateLoadingImplCopyWithImpl(
      _$ReactToEchoCommentStateLoadingImpl _value,
      $Res Function(_$ReactToEchoCommentStateLoadingImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ReactToEchoCommentStateLoadingImpl
    implements _ReactToEchoCommentStateLoading {
  const _$ReactToEchoCommentStateLoadingImpl();

  @override
  String toString() {
    return 'ReactToEchoCommentState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ReactToEchoCommentStateLoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(PeamanReaction result) success,
    required TResult Function(PeamanError error) error,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(PeamanReaction result)? success,
    TResult? Function(PeamanError error)? error,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(PeamanReaction result)? success,
    TResult Function(PeamanError error)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ReactToEchoCommentStateInitial value) initial,
    required TResult Function(_ReactToEchoCommentStateLoading value) loading,
    required TResult Function(_ReactToEchoCommentStateSuccess value) success,
    required TResult Function(_ReactToEchoCommentStateError value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_ReactToEchoCommentStateInitial value)? initial,
    TResult? Function(_ReactToEchoCommentStateLoading value)? loading,
    TResult? Function(_ReactToEchoCommentStateSuccess value)? success,
    TResult? Function(_ReactToEchoCommentStateError value)? error,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ReactToEchoCommentStateInitial value)? initial,
    TResult Function(_ReactToEchoCommentStateLoading value)? loading,
    TResult Function(_ReactToEchoCommentStateSuccess value)? success,
    TResult Function(_ReactToEchoCommentStateError value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _ReactToEchoCommentStateLoading
    implements ReactToEchoCommentState {
  const factory _ReactToEchoCommentStateLoading() =
      _$ReactToEchoCommentStateLoadingImpl;
}

/// @nodoc
abstract class _$$ReactToEchoCommentStateSuccessImplCopyWith<$Res> {
  factory _$$ReactToEchoCommentStateSuccessImplCopyWith(
          _$ReactToEchoCommentStateSuccessImpl value,
          $Res Function(_$ReactToEchoCommentStateSuccessImpl) then) =
      __$$ReactToEchoCommentStateSuccessImplCopyWithImpl<$Res>;
  @useResult
  $Res call({PeamanReaction result});

  $PeamanReactionCopyWith<$Res> get result;
}

/// @nodoc
class __$$ReactToEchoCommentStateSuccessImplCopyWithImpl<$Res>
    extends _$ReactToEchoCommentStateCopyWithImpl<$Res,
        _$ReactToEchoCommentStateSuccessImpl>
    implements _$$ReactToEchoCommentStateSuccessImplCopyWith<$Res> {
  __$$ReactToEchoCommentStateSuccessImplCopyWithImpl(
      _$ReactToEchoCommentStateSuccessImpl _value,
      $Res Function(_$ReactToEchoCommentStateSuccessImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? result = null,
  }) {
    return _then(_$ReactToEchoCommentStateSuccessImpl(
      null == result
          ? _value.result
          : result // ignore: cast_nullable_to_non_nullable
              as PeamanReaction,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $PeamanReactionCopyWith<$Res> get result {
    return $PeamanReactionCopyWith<$Res>(_value.result, (value) {
      return _then(_value.copyWith(result: value));
    });
  }
}

/// @nodoc

class _$ReactToEchoCommentStateSuccessImpl
    implements _ReactToEchoCommentStateSuccess {
  const _$ReactToEchoCommentStateSuccessImpl(this.result);

  @override
  final PeamanReaction result;

  @override
  String toString() {
    return 'ReactToEchoCommentState.success(result: $result)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ReactToEchoCommentStateSuccessImpl &&
            (identical(other.result, result) || other.result == result));
  }

  @override
  int get hashCode => Object.hash(runtimeType, result);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ReactToEchoCommentStateSuccessImplCopyWith<
          _$ReactToEchoCommentStateSuccessImpl>
      get copyWith => __$$ReactToEchoCommentStateSuccessImplCopyWithImpl<
          _$ReactToEchoCommentStateSuccessImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(PeamanReaction result) success,
    required TResult Function(PeamanError error) error,
  }) {
    return success(result);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(PeamanReaction result)? success,
    TResult? Function(PeamanError error)? error,
  }) {
    return success?.call(result);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(PeamanReaction result)? success,
    TResult Function(PeamanError error)? error,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(result);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ReactToEchoCommentStateInitial value) initial,
    required TResult Function(_ReactToEchoCommentStateLoading value) loading,
    required TResult Function(_ReactToEchoCommentStateSuccess value) success,
    required TResult Function(_ReactToEchoCommentStateError value) error,
  }) {
    return success(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_ReactToEchoCommentStateInitial value)? initial,
    TResult? Function(_ReactToEchoCommentStateLoading value)? loading,
    TResult? Function(_ReactToEchoCommentStateSuccess value)? success,
    TResult? Function(_ReactToEchoCommentStateError value)? error,
  }) {
    return success?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ReactToEchoCommentStateInitial value)? initial,
    TResult Function(_ReactToEchoCommentStateLoading value)? loading,
    TResult Function(_ReactToEchoCommentStateSuccess value)? success,
    TResult Function(_ReactToEchoCommentStateError value)? error,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(this);
    }
    return orElse();
  }
}

abstract class _ReactToEchoCommentStateSuccess
    implements ReactToEchoCommentState {
  const factory _ReactToEchoCommentStateSuccess(final PeamanReaction result) =
      _$ReactToEchoCommentStateSuccessImpl;

  PeamanReaction get result;
  @JsonKey(ignore: true)
  _$$ReactToEchoCommentStateSuccessImplCopyWith<
          _$ReactToEchoCommentStateSuccessImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ReactToEchoCommentStateErrorImplCopyWith<$Res> {
  factory _$$ReactToEchoCommentStateErrorImplCopyWith(
          _$ReactToEchoCommentStateErrorImpl value,
          $Res Function(_$ReactToEchoCommentStateErrorImpl) then) =
      __$$ReactToEchoCommentStateErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({PeamanError error});

  $PeamanErrorCopyWith<$Res> get error;
}

/// @nodoc
class __$$ReactToEchoCommentStateErrorImplCopyWithImpl<$Res>
    extends _$ReactToEchoCommentStateCopyWithImpl<$Res,
        _$ReactToEchoCommentStateErrorImpl>
    implements _$$ReactToEchoCommentStateErrorImplCopyWith<$Res> {
  __$$ReactToEchoCommentStateErrorImplCopyWithImpl(
      _$ReactToEchoCommentStateErrorImpl _value,
      $Res Function(_$ReactToEchoCommentStateErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = null,
  }) {
    return _then(_$ReactToEchoCommentStateErrorImpl(
      null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as PeamanError,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $PeamanErrorCopyWith<$Res> get error {
    return $PeamanErrorCopyWith<$Res>(_value.error, (value) {
      return _then(_value.copyWith(error: value));
    });
  }
}

/// @nodoc

class _$ReactToEchoCommentStateErrorImpl
    implements _ReactToEchoCommentStateError {
  const _$ReactToEchoCommentStateErrorImpl(this.error);

  @override
  final PeamanError error;

  @override
  String toString() {
    return 'ReactToEchoCommentState.error(error: $error)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ReactToEchoCommentStateErrorImpl &&
            (identical(other.error, error) || other.error == error));
  }

  @override
  int get hashCode => Object.hash(runtimeType, error);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ReactToEchoCommentStateErrorImplCopyWith<
          _$ReactToEchoCommentStateErrorImpl>
      get copyWith => __$$ReactToEchoCommentStateErrorImplCopyWithImpl<
          _$ReactToEchoCommentStateErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(PeamanReaction result) success,
    required TResult Function(PeamanError error) error,
  }) {
    return error(this.error);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(PeamanReaction result)? success,
    TResult? Function(PeamanError error)? error,
  }) {
    return error?.call(this.error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(PeamanReaction result)? success,
    TResult Function(PeamanError error)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this.error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ReactToEchoCommentStateInitial value) initial,
    required TResult Function(_ReactToEchoCommentStateLoading value) loading,
    required TResult Function(_ReactToEchoCommentStateSuccess value) success,
    required TResult Function(_ReactToEchoCommentStateError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_ReactToEchoCommentStateInitial value)? initial,
    TResult? Function(_ReactToEchoCommentStateLoading value)? loading,
    TResult? Function(_ReactToEchoCommentStateSuccess value)? success,
    TResult? Function(_ReactToEchoCommentStateError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ReactToEchoCommentStateInitial value)? initial,
    TResult Function(_ReactToEchoCommentStateLoading value)? loading,
    TResult Function(_ReactToEchoCommentStateSuccess value)? success,
    TResult Function(_ReactToEchoCommentStateError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class _ReactToEchoCommentStateError
    implements ReactToEchoCommentState {
  const factory _ReactToEchoCommentStateError(final PeamanError error) =
      _$ReactToEchoCommentStateErrorImpl;

  PeamanError get error;
  @JsonKey(ignore: true)
  _$$ReactToEchoCommentStateErrorImplCopyWith<
          _$ReactToEchoCommentStateErrorImpl>
      get copyWith => throw _privateConstructorUsedError;
}
